const 原理

C语言可以通过指针修改const变量的值，const变量存在内存

C++ 编译器在编译时对基本类型（例如int，short，long等）的常量进行了替换，通过指针修改基本类型的常量是运行时进行的，不影响原常量的值

对于类内部基本类型常量，通过指针修改会改变该常量的值


res：
i=10 ,*p= 10
&i=0x7fff36758a84 ,p= 0x7fff36758a84
i=10 ,*p= 20 ,*&i10
a.i=3
a.i=3 ,pa->i=3
a.i=5 ,pa->i=5
b.i=5
b.i=6 ,b->i=6
b.i=7 ,b->i=7


问题1，对于const int类型的变量i，C语言中通过指针p修改了值后，i变成了20；而在C++中，通过指针p修改了值后，i仍然是10。
问题2，C++语言中 const struct test的元素j通过指针q被改变了，为何const int 与 const struct test的反应机制不同？
针对问题1，我们知道C语言中const表示只读的变量，既然把const看成是变量，那么其在内存中就会有存储他的空间，并且可以通过指针间接的改变该内存空间的值，当通过指针p改变该内存中的值后，再获取i的值的时候，会访问该空间，得到的是被改变后的值。而C++把const看做常量，编译器会使用常数直接替换掉对i的引用，例如cout<<i; 会理解成cout<<10; 并不会去访问i的内存地址去取数据，这里有点像是C语言里的宏#define i 10。因此C++里i会输出10，而*p会输出20.
针对问题2，C++语言中只是对于内置数据类型做常数替换，而对于像结构体这样的非内置数据类型则不会。因为结构体类型不是内置数据类型，编译器不知道如何直接替换，因此必须要访问内存去取数据，而访问内存去取数据必然会取到被指针q改变后的值，因此会造成与C++中const int类型完全不一样的处理模式。
